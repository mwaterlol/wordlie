{"version":3,"file":"jsx-lexer.js","names":["JavascriptLexer","ts","unescape","JsxLexer","_JavascriptLexer","_this","options","arguments","length","undefined","_classCallCheck","_callSuper","componentFunctions","transSupportBasicHtmlNodes","transKeepBasicHtmlNodesFor","omitAttributes","attr","transIdentityFunctionsToIgnore","_inherits","_createClass","key","value","extract","content","_this2","filename","keys","parseCommentNode","createCommentNodeParser","parseTree","node","entry","kind","SyntaxKind","CallExpression","entries","expressionExtractor","call","push","apply","_toConsumableArray","TaggedTemplateExpression","taggedTemplateExpressionExtractor","JsxElement","jsxExtractor","JsxSelfClosingElement","forEachChild","sourceFile","createSourceFile","ScriptTarget","Latest","keysWithNamespace","setNamespaces","keysWithPrefixes","setKeyPrefixes","sourceText","_this3","tagNode","openingElement","getPropValue","attributeName","_attribute$initialize","attribute","attributes","properties","find","name","text","initializer","expression","Identifier","emit","concat","getKey","includes","expressionToName","tagName","namespace","forEach","property","JsxSpreadAttribute","TrueKeyword","FalseKeyword","cleanMultiLineCode","slice","pos","end","nodeAsString","nodeToString","defaultsProp","defaultValue","shouldUnescape","defaultNamespace","_this4","children","parseChildren","elemsToString","map","child","index","type","useTagName","isBasic","elementName","childrenString","selfClosing","Error","join","replace","_this5","JsxText","element","escapedText","hasDynamicChildren","prop","JsxAttribute","JsxExpression","AsExpression","StringLiteral","ObjectLiteralExpression","nonFormatProperties","filter","formatProperty","slicedExpression","attrValues","_attr$name","_attr$initializer$exp","_attr$initializer$exp2","some","default"],"sources":["../../src/lexers/jsx-lexer.js"],"sourcesContent":["import JavascriptLexer from './javascript-lexer.js'\nimport ts from 'typescript'\nimport { unescape } from '../helpers.js'\n\nexport default class JsxLexer extends JavascriptLexer {\n  constructor(options = {}) {\n    super(options)\n\n    this.componentFunctions = options.componentFunctions || ['Trans']\n    this.transSupportBasicHtmlNodes =\n      options.transSupportBasicHtmlNodes || false\n    this.transKeepBasicHtmlNodesFor = options.transKeepBasicHtmlNodesFor || [\n      'br',\n      'strong',\n      'i',\n      'p',\n    ]\n    this.omitAttributes = [this.attr, 'ns', 'defaults']\n    this.transIdentityFunctionsToIgnore =\n      options.transIdentityFunctionsToIgnore || []\n  }\n\n  extract(content, filename = '__default.jsx') {\n    const keys = []\n\n    const parseCommentNode = this.createCommentNodeParser()\n\n    const parseTree = (node) => {\n      let entry\n\n      parseCommentNode(keys, node, content)\n\n      switch (node.kind) {\n        case ts.SyntaxKind.CallExpression:\n          const entries = this.expressionExtractor.call(this, node)\n          if (entries) {\n            keys.push(...entries)\n          }\n          break\n        case ts.SyntaxKind.TaggedTemplateExpression:\n          entry = this.taggedTemplateExpressionExtractor.call(this, node)\n          break\n        case ts.SyntaxKind.JsxElement:\n          entry = this.jsxExtractor.call(this, node, content)\n          break\n        case ts.SyntaxKind.JsxSelfClosingElement:\n          entry = this.jsxExtractor.call(this, node, content)\n          break\n      }\n\n      if (entry) {\n        keys.push(entry)\n      }\n\n      node.forEachChild(parseTree)\n    }\n\n    const sourceFile = ts.createSourceFile(\n      filename,\n      content,\n      ts.ScriptTarget.Latest\n    )\n    parseTree(sourceFile)\n\n    const keysWithNamespace = this.setNamespaces(keys)\n    const keysWithPrefixes = this.setKeyPrefixes(keysWithNamespace)\n\n    return keysWithPrefixes\n  }\n\n  jsxExtractor(node, sourceText) {\n    const tagNode = node.openingElement || node\n\n    const getPropValue = (node, attributeName) => {\n      const attribute = node.attributes.properties.find(\n        (attr) => attr.name !== undefined && attr.name.text === attributeName\n      )\n      if (!attribute) {\n        return undefined\n      }\n\n      if (attribute.initializer.expression?.kind === ts.SyntaxKind.Identifier) {\n        this.emit(\n          'warning',\n          `\"${attributeName}\" prop is not a string literal: ${attribute.initializer.expression.text}`\n        )\n\n        return undefined\n      }\n\n      return attribute.initializer.expression\n        ? attribute.initializer.expression.text\n        : attribute.initializer.text\n    }\n\n    const getKey = (node) => getPropValue(node, this.attr)\n\n    if (\n      this.componentFunctions.includes(this.expressionToName(tagNode.tagName))\n    ) {\n      const entry = {}\n      entry.key = getKey(tagNode)\n\n      const namespace = getPropValue(tagNode, 'ns')\n      if (namespace) {\n        entry.namespace = namespace\n      }\n\n      tagNode.attributes.properties.forEach((property) => {\n        if (property.kind === ts.SyntaxKind.JsxSpreadAttribute) {\n          this.emit(\n            'warning',\n            `Component attribute is a JSX spread attribute : ${property.expression.text}`\n          )\n          return\n        }\n\n        if (this.omitAttributes.includes(property.name.text)) {\n          return\n        }\n\n        if (property.initializer) {\n          if (property.initializer.expression) {\n            if (\n              property.initializer.expression.kind === ts.SyntaxKind.TrueKeyword\n            ) {\n              entry[property.name.text] = true\n            } else if (\n              property.initializer.expression.kind ===\n              ts.SyntaxKind.FalseKeyword\n            ) {\n              entry[property.name.text] = false\n            } else {\n              entry[property.name.text] = `{${\n                property.initializer.expression.text ||\n                this.cleanMultiLineCode(\n                  sourceText.slice(\n                    property.initializer.expression.pos,\n                    property.initializer.expression.end\n                  )\n                )\n              }}`\n            }\n          } else {\n            entry[property.name.text] = property.initializer.text\n          }\n        } else entry[property.name.text] = true\n      })\n\n      const nodeAsString = this.nodeToString.call(this, node, sourceText)\n      const defaultsProp = getPropValue(tagNode, 'defaults')\n      let defaultValue = defaultsProp || nodeAsString\n\n      // If `shouldUnescape` is not true, it means the value cannot contain HTML entities,\n      // so we need to unescape these entities now so that they can be properly rendered later\n      if (entry.shouldUnescape !== true) {\n        defaultValue = unescape(defaultValue)\n      }\n\n      if (defaultValue !== '') {\n        entry.defaultValue = defaultValue\n\n        if (!entry.key) {\n          // If there's no key, default to the stringified unescaped node, then to the default value:\n          // https://github.com/i18next/react-i18next/blob/95f9c6a7b602a7b1fd33c1ded6dcfc23a52b853b/src/TransWithoutContext.js#L337\n          entry.key = unescape(nodeAsString) || entry.defaultValue\n        }\n      }\n\n      return entry.key ? entry : null\n    } else if (tagNode.tagName.text === 'Interpolate') {\n      const entry = {}\n      entry.key = getKey(tagNode)\n      return entry.key ? entry : null\n    } else if (tagNode.tagName.text === 'Translation') {\n      const namespace = getPropValue(tagNode, 'ns')\n      if (namespace) {\n        this.defaultNamespace = namespace\n      }\n    }\n  }\n\n  nodeToString(node, sourceText) {\n    const children = this.parseChildren.call(\n      this,\n      node,\n      node.children,\n      sourceText\n    )\n\n    const elemsToString = (children) =>\n      children\n        .map((child, index) => {\n          switch (child.type) {\n            case 'js':\n            case 'text':\n              return child.content\n            case 'tag':\n              const useTagName =\n                child.isBasic &&\n                this.transSupportBasicHtmlNodes &&\n                this.transKeepBasicHtmlNodesFor.includes(child.name)\n              const elementName = useTagName ? child.name : index\n              const childrenString = elemsToString(child.children)\n              return childrenString || !(useTagName && child.selfClosing)\n                ? `<${elementName}>${childrenString}</${elementName}>`\n                : `<${elementName} />`\n            default:\n              throw new Error('Unknown parsed content: ' + child.type)\n          }\n        })\n        .join('')\n\n    return elemsToString(children)\n  }\n\n  cleanMultiLineCode(text) {\n    return text\n      .replace(/(^(\\n|\\r)\\s*)|((\\n|\\r)\\s*$)/g, '')\n      .replace(/(\\n|\\r)\\s*/g, ' ')\n  }\n\n  parseChildren(node, children = [], sourceText) {\n    return children\n      .map((child) => {\n        if (child.kind === ts.SyntaxKind.JsxText) {\n          return {\n            type: 'text',\n            content: this.cleanMultiLineCode(child.text),\n          }\n        } else if (\n          child.kind === ts.SyntaxKind.JsxElement ||\n          child.kind === ts.SyntaxKind.JsxSelfClosingElement\n        ) {\n          const element = child.openingElement || child\n          const name = element.tagName.escapedText\n          const isBasic = !element.attributes.properties.length\n          const hasDynamicChildren = element.attributes.properties.find(\n            (prop) =>\n              prop.kind === ts.SyntaxKind.JsxAttribute &&\n              prop.name.escapedText === 'i18nIsDynamicList'\n          )\n          return {\n            type: 'tag',\n            children: hasDynamicChildren\n              ? []\n              : this.parseChildren(child, child.children, sourceText),\n            name,\n            isBasic,\n            selfClosing: child.kind === ts.SyntaxKind.JsxSelfClosingElement,\n          }\n        } else if (child.kind === ts.SyntaxKind.JsxExpression) {\n          // strip empty expressions\n          if (!child.expression) {\n            return {\n              type: 'text',\n              content: '',\n            }\n          }\n\n          // simplify trivial expressions, like TypeScript typecasts\n          while (child.expression.kind === ts.SyntaxKind.AsExpression) {\n            child = child.expression\n          }\n\n          // Sometimes, we might want to wrap ObjectExpressions in a function\n          // for typechecker compatibility: e.g.,\n          //\n          // Instead of\n          // `<Trans>Hello, <Link to=\"/\">{{ name }}</Link></Trans>`\n          // we might want:\n          // `<Trans>Hello, <Link to=\"/\">{castToString({ name })}</Link></Trans>`\n          //\n          // because that way, we can have {castToString(...)} be typed\n          // in a a way to return a string, which would be type-compatible\n          // with `children?: React.ReactNode`\n          //\n          // In these cases, we want to look at the object expressions within\n          // the function call to extract the variables\n          if (\n            child.expression.kind === ts.SyntaxKind.CallExpression &&\n            child.expression.expression.kind === ts.SyntaxKind.Identifier &&\n            this.transIdentityFunctionsToIgnore.includes(\n              child.expression.expression.escapedText\n            ) &&\n            child.expression.arguments.length >= 1\n          ) {\n            child = { expression: child.expression.arguments[0] }\n          }\n\n          if (child.expression.kind === ts.SyntaxKind.StringLiteral) {\n            return {\n              type: 'text',\n              content: child.expression.text,\n            }\n          }\n\n          // strip properties from ObjectExpressions\n          // annoying (and who knows how many other exceptions we'll need to write) but necessary\n          else if (\n            child.expression.kind === ts.SyntaxKind.ObjectLiteralExpression\n          ) {\n            // i18next-react only accepts two props, any random single prop, and a format prop\n\n            const nonFormatProperties = child.expression.properties.filter(\n              (prop) => prop.name.text !== 'format'\n            )\n            const formatProperty = child.expression.properties.find(\n              (prop) => prop.name.text === 'format'\n            )\n\n            // more than one property throw a warning in i18next-react, but still works as a key\n            if (nonFormatProperties.length > 1) {\n              this.emit(\n                'warning',\n                `The passed in object contained more than one variable - the object should look like {{ value, format }} where format is optional.`\n              )\n\n              return {\n                type: 'text',\n                content: '',\n              }\n            }\n\n            // This matches the behaviour of the Trans component in i18next as of v13.0.2:\n            // https://github.com/i18next/react-i18next/blob/0a4681e428c888fe986bcc0109eb19eab6ff2eb3/src/TransWithoutContext.js#L88\n            const value = formatProperty\n              ? `${nonFormatProperties[0].name.text}, ${formatProperty.initializer.text}`\n              : nonFormatProperties[0].name.text\n\n            return {\n              type: 'js',\n              content: `{{${value}}}`,\n            }\n          }\n\n          // slice on the expression so that we ignore comments around it\n          const slicedExpression = sourceText.slice(\n            child.expression.pos,\n            child.expression.end\n          )\n\n          const tagNode = node.openingElement || node\n          const attrValues = tagNode.attributes.properties\n            .filter((attr) => [this.attr, 'defaults'].includes(attr.name?.text))\n            .map(\n              (attr) =>\n                attr.initializer.expression?.text ?? attr.initializer.text\n            )\n\n          if (attrValues.some((attr) => !attr)) {\n            this.emit('warning', `Child is not literal: ${slicedExpression}`)\n          }\n\n          return {\n            type: 'js',\n            content: `{${slicedExpression}}`,\n          }\n        } else {\n          throw new Error('Unknown ast element when parsing jsx: ' + child.kind)\n        }\n      })\n      .filter((child) => child.type !== 'text' || child.content)\n  }\n}\n"],"mappings":"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"}